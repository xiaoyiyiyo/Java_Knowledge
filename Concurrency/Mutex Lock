标准的互斥锁：
每次最多只有一个线程能持有锁，也是独占锁的概念。读/读，写/写，写/读操作都不能同时发生。
比如 内置锁：
java提供内置的锁机制为同步代码块(synchronized block), 同步代码块包括两个部分： 
1.作为锁的对象引用 2. 作为由这个锁保护的代码块。
synchronized(object){
}
每个java对象都可以用做一个实现同步的锁，这些锁即被成为内置锁或监视器锁。
注意：并不能认为同步代码块或关键字synchronized只能用于实现原子性或者确定临界区，其还可用于另外一个重要方面：内存可见性, 如下：
//NotThreadSafe
public class MutableInteger{
  private int value;
  public int get(){return value;}
  public void set(int value){this.value=value;}
}
可对get和set方法进行同步(synchronized),使之成为线程安全类。

ReentrantLock(重入锁):
Java5.0增加的一种锁机制，其并不是一种替代内置锁的方法，而是当内置锁不适用时，可供选择的高级方式。
基本语法上, ReentrantLock 与 synchronized 很相似, 它们都具备一样的线程重入特性，只是代码写法上有点区别而已，一个表现为 API 层面的互斥锁（Lock），
一个表现为原生语法层面的互斥锁（synchronized）。
基本形式:
Lock lock = new ReentrantLock();
...
lock.lock();
try{
  //do some action
} finally {
  lock.unlock();
}
高级功能：
1. 可定时 2. 可轮询 3. 可中断 4. 公平队列 5. 非块结构加锁
举例: 带有时间限制的加锁
public boolean trySendOnSharedLine(String message, long timeout, TimeUnit unit)
  throw InterruptedException{
  long nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);
  if(!lock.tryLock(nanosToLock, NANOSECONDS))     //可定时
    return false;
  try{
    return sendOnSharedLine(message);
  } finally {
    lock.unlock();
  }
}
