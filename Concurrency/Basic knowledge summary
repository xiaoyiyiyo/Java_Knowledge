                                                                                   +--->  管道 pipeline
                                                                                   |
       +--> 架构层面                                                                +--->  信号 signal
       |                                                                           |
高并发                             +----> 线程安全 +---> 线程同步 +---> 线 程 通 信   +--->  消息队列 messsage queue
       |                          |                                                |                               +--->  可见性
       +--> 代码层面  +---> 多线程  +----> 性能                                      +--->  共享内存 shared memory   |
                                  |                                                |                               +--->  有序性
                                  +----> ......                                    +--->  信号量 semaphore
                                                                                   |
                                                                                   +--->  套接字 socket
加上复合操作的原子性，多线程安全问题的主要关注点：
1. 原子性
2. 可见性 
3. 有序性

原子性：
问题： 复合操作由于不恰当的执行时序而出现不正确的结果，即存在 竞态条件(Race Condition) 也遇到了某种不恰当的执行时序。
      常见的竞态条件类型：“读取-修改-写入” 如：++count 
                        “先检查后执行(Check-Then-Act)”, 常见情况为：延迟初始化 getInstance()
java解决原子性的问题主要通过锁/互斥实现。
锁机制： 
锁的本质是等待，等待的方式有两种
1. 线程阻塞   (被唤醒的代价比较高,保存用户态的上下文进入内核态，即上下文切换)      互斥锁
2. 线程自旋   (持续执行空代码,白白消耗资源)                                     自旋锁
java自带的sychronized采取的是折中的方案, 先自旋一段时间，还没拿到锁就进入阻塞(混合型互斥锁)
