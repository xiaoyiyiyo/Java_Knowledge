                                                                                   +--->  管道 pipeline
                                                                                   |
       +--> 架构层面                                                                +--->  信号 signal
       |                                                                           |
高并发                             +----> 线程安全 +---> 线程同步 +---> 线 程 通 信   +--->  消息队列 messsage queue
       |                          |                                                |                               +--->  可见性
       +--> 代码层面  +---> 多线程  +----> 性能                                      +--->  共享内存 shared memory   |
                                  |                                                |                               +--->  有序性
                                  +----> 活跃性                                     +--->  信号量 semaphore
                                  |                                                |
                                  +----> ...                                       +--->  套接字 socket
                                  
加上复合操作的原子性，多线程安全问题的主要关注点：
1. 原子性
2. 可见性 
3. 有序性

原子性：
问题： 复合操作由于不恰当的执行时序而出现不正确的结果，即存在 竞态条件(Race Condition) 也遇到了某种不恰当的执行时序。
      常见的竞态条件类型：“读取-修改-写入” 如：++count 
                        “先检查后执行(Check-Then-Act)”, 常见情况为：延迟初始化 getInstance()
java解决原子性的问题主要通过锁/互斥实现。
锁机制： 
锁的本质是等待，等待的方式有两种
1. 线程阻塞   (被唤醒的代价比较高,保存用户态的上下文进入内核态，即上下文切换)      互斥锁
2. 线程自旋   (持续执行空代码,白白消耗资源)                                     自旋锁
java自带的sychronized采取的是折中的方案, 先自旋一段时间，还没拿到锁就进入阻塞(混合型互斥锁)
无锁概念：
相对于独占锁的悲观技术，其采用一种乐观的方法，借助冲突检测机制来判断在更新过程中是否存在其它线程的干扰，如果存在，则失败，并可以重试(
也可以不重试)。冲突检测机制普遍采用的是比较并交换(CAS)，提到无锁，基本上就指向CAS的概念。
java5.0后在int, long和对象的引用等类型上都公开了CAS操作(原子变量类 java.util.concurrent.atomic中的 AtomicXxx)，JVM把它们编译为相应的机器指令，
所以是高效的。


可见性：
